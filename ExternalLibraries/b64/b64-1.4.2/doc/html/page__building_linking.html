<head>
 <link href="b64.css" rel="stylesheet" type="text/css">
</head>

<table width = "100%">
 <tr>
<!--
  <td align = "center" valign = "middle">
   <a href = "http://www.cuj.com/"><img src = "cuj_logo.gif" border = "0" width = "155" height = "50" alt = "C/C++ User's Journal" /></a>
  </td>
-->
  <td align = "left" valign = "middle">
   <a href = "http://www.synesis.com.au/"><img src = "syn_head.jpg" border = "0" width = "343" height = "50" alt = "Synesis Software" /></a>
  </td>
  <td align = "right" valign = "middle">
   <a href = "http://stlsoft.org"><img src = "stlsoft200x100.jpg" border = "0" width = "100" height = "50" alt = "STLSoft - ... Robust, Lightweight, Cross-platform, Template Software ..." /></a>
  </td>
<!--
  <td align = "center" valign = "middle">
   <a href = "http://atlstl.org"><img src = "atlstl200x100.jpg" border = "0" width = "100" height = "50" alt = "ATLSTL - where the Standard Template Library meets the Active Template Library" /></a>
  </td>
-->
<!--
  <td align = "center" valign = "middle">
   <a href = "http://comstl.org"><img src = "comstl200x100.jpg" border = "0" width = "100" height = "50" alt = "COMSTL - where the Standard Template Library meets the Component Object Model" /></a>
  </td>
-->
<!--
  <td align = "center" valign = "middle">
   <a href = "http://inetstl.org"><img src = "inetstl200x100.jpg" border = "0" width = "100" height = "50" alt = "InetSTL - where the Standard Template Library meets the Internet" /></a>
  </td>
-->
<!--
  <td align = "center" valign = "middle">
   <a href = "http://unixstl.org"><img src = "unixstl200x100.jpg" border = "0" width = "100" height = "50" alt = "UNIXSTL - Template Software for the UNIX Operating System" /></a>
  </td>
  <td align = "center" valign = "middle">
   <a href = "http://winstl.org"><img src = "winstl200x100.jpg" border = "0" width = "100" height = "50" alt = "WinSTL - where the Standard Template Library meets the Win32 API" /></a>
  </td>
-->
 </tr>
 <tr>
  <td width = "100%" colspan = "2">
   <hr width = "100%">
  </td>
 </tr>
</table>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="page__building_linking">Building and Linking to the Libraries </a></h1><h2><a class="anchor" name="section__installing">
Installing the library</a></h2>
b64 comes as a source-only distribution, meaning that you will need to build the library before you can use it. The core library is self-contained, but the C++ layer depends on the <a href="http://stlsoft.org/">STLSoft</a> libraries (an open-source, 100% header-only, suite of lightweight C++ libraries, also using the <a href="http://www.opensource.org/licenses/bsd-license.html">BSD</a> license).<p>
The distribution is in the form of a zip file, e.g. <code>b64-1.1.1.zip</code> which you should extract (recursively) to a location of your choice, e.g. c:\opensrc\b64\1.1, or ~/opensrc/b64/1.1, which will be referred to in the subsequent documentation as <code>&lt;B64-install-dir&gt;</code>.<h2><a class="anchor" name="section__building">
Building the library for your compiler(s)</a></h2>
<h3><a class="anchor" name="section__building__makefile">
Via makefile</a></h3>
Makefiles for all the main supported compilers are included in the subdirectories of the <code>build</code> directory. For example, the makefile for Borland C/C++ v5.6 is in <code>build/vc6</code>. Since Borland is only supported on Windows, there is a single makefile called <code>makefile</code>.<p>
Hence, to build <b>b64</b> for Borland C/C++ 5.6 you need open a Windows command box (with the environment set up for the compiler and linker) and execute the following command:<p>
<code>&nbsp;&nbsp;&lt;B64-install-dir&gt;\build\bc56&gt; <b>make -f makefile</b></code><p>
or just:<p>
<code>&nbsp;&nbsp;&lt;B64-install-dir&gt;\build\bc56&gt; <b>make</b></code><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For compilers that are supported on more than one platform, there are several makefiles located in the build sub-directory. For example, for GNU C/C++ v3.4 (in <code><code>&lt;B64-install-dir&gt;</code>/build/gcc34</code>) both <code>makefile.unix</code> and <code>makefile.win32</code> are provided. Most <code>make</code> tools require that you explicitly specify the makefile name (using <code>-f</code>) to use such makefiles, e.g. <code><b>make -f makefile.unix</b></code>.</dd></dl>
This will build the b64 library, and the C test programs. It will also attempt to build the C++ test programs. Since the C++ layer relies on the STLSoft libraries, the makefile will look for the environment variable <code>STLSOFT</code>: it specifies <code>-I%STLSOFT%/include</code> (Windows) / <code>-I$STLSOFT/include</code> (UNIX) to the compiler for C++ compilation. If the <code>STLSOFT</code> environment variable is not defined or does not correspond to an installation of STLSoft, then the build will fail, although it will successfully build the core library and the C samples and test programs.<h3><a class="anchor" name="section__building__vc6_project">
With the Visual C++ 6.0 project file</a></h3>
Also included are Visual C++ 6.0 project files for the core library and the samples and test programs. These files can be read (and converted) by any later version of Visual C++.<p>
Just open the workspace file <code>b64_vc6.dsw</code>, located in the root directory (i.e. <code>&lt;B64-install-dir&gt;</code>), and select the Build-All option.<h2><a class="anchor" name="section__linking">
Linking the library</a></h2>
There are two options for linking to the core library: explicit linking and implicit linking.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There is no notion of "linking" to the C++ layer because it is 100% header-only.</dd></dl>
<h3><a class="anchor" name="section__linking__explicit_linking">
Explicit Linking</a></h3>
Explicit linking requires that you stipulate the requisite library name (and associated path) to your compiler/linker.<p>
For example, if you are using the Borland compiler, version 5.6, you would link to the library <code>b64.1.bc56.debug.lib</code> in a debug build and <code>b64.1.bc56.lib</code> in a release build. Say you wish to compile and build the example.c.1.c sample, that resides in <code>&lt;B64-install-dir&gt;</code>\samples\c\example.c.1.c.<p>
You could compile it:<p>
<code>&lt;B64-install-dir&gt;\samples\c\example.c.1.c6&gt; <b>bcc32 -c -I..\..\..\include</b></code><p>
and then link it:<p>
<code>&lt;B64-install-dir&gt;\samples\c\example.c.1.c6&gt; <b>bcc32 -L..\..\..\lib example.c.1.obj b64.1.bc56.lib</b></code><p>
With most compilers, you can do this in one step, as in:<p>
<code>&lt;B64-install-dir&gt;\samples\c\example.c.1.c6&gt; <b>bcc32 -I..\..\..\include<b></b> -L..\..\..\lib example.c.1.c b64.1.bc56.lib</b></code><h3><a class="anchor" name="section__linking__optional_implicit_linking">
Optional Implicit Linking</a></h3>
Some compilers support implicit linking, which involves the compiler inserting information into the object file during the compilation phase that directs the linker to the name of the required library. b64 supports implicit linking for Borland, Metrowerks CodeWarrior, Intel, and Visual C++ compilers. To use implicit linking, simply <code>#include</code> the file <code>&lt;<a class="el" href="b64_2implicit__link_8h.html" title="[C/C++] Implicit linking for the b64 API">b64/implicit_link.h</a>&gt;</code> in the file that is using the b64 library, as in:<p>
 
<pre>
  #include &lt;b64/b64.h&gt;
  #include &lt;<b>b64/implicit_link.h</b>&gt;

  int main()
  {
    int     ints[]  = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    size_t  cch     = b64_encode(&ints[0], sizeof(ints), NULL, 0);  &#x2f;&#x2a; Ask for length required &#x2a;&#x2f;
    char*   enc     = (char*)malloc(cch);                           &#x2f;&#x2a; No error checking here ... real code must do so &#x2a;&#x2f;

    b64_encode(&ints[0], sizeof(ints), enc, cch);

    printf("Converted: %.*s\n", cch, enc);

    return 0;
  }
</pre>
<p>
When you compile and link this file you will not have to specify the library name. You will still have to specify the library path, however, if it is not in the default linker path(s) for your compiler/linker. The above example reduces to:<p>
<code>&lt;B64-install-dir&gt;\samples\c\example.c.1.c6&gt; <b>bcc32 -I..\..\..\include<b></b> -L..\..\..\lib example.c.1.c</b></code><p>
but <b>not</b> to:<p>
<code>&lt;B64-install-dir&gt;\samples\c\example.c.1.c6&gt; <b>bcc32 -I..\..\..\include<b></b> example.c.1.c</b></code><p>
(whereupon the compiler will complain about not knowing the location of <code>b64.1.bc56.lib</code>).<p>
There are two advantages of implicit linking:<p>
<ol>
<li>
If you build your product in several versions (e.g. debug and release), you do not have to worry about specifying the different names of the requisite libraries. </li>
<li>
If you use libraries that are dependent on other libraries, you do not have to remember which other library names are needed by the intermediate libraries. </li>
</ol>
<p>
<b>Note</b>: In both cases above (indeed, in <b>all</b> cases), you do need to provide the linker with the library directories if they do not reside in the default linker path(s) for your compiler/linker <table width = "100%">
 <tr>
  <td width = "100%">
   <hr width = "100%">
  </td>
 </tr>
 <tr>
  <td align = "center" valign = "middle">
   <font size = "-1">
    <a href = "http://www.synesis.com.au/software/"><b>b64</b></a>
    Library documentation 
    <a href = "http://synesis.com.au/">© Synesis Software Pty Ltd, 2004-2012</a>
   </font>
  </td>
 </tr>
</table>
